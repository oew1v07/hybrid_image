\RequirePackage[l2tabu, orthodox]{nag}

\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{layout}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{microtype}
\usepackage{bm}
\usepackage{titling}
\usepackage[a4paper]{geometry}
\usepackage{parskip}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{subcaption}


\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{cleveref}

\newcommand{\todo}[1] {\textbf{\textcolor{red}{#1}}}
\makeatletter
\newcommand{\xRightarrow}[2][]{\ext@arrow 0359\Rightarrowfill@{#1}{#2}}
\makeatother

\fancyhead{}
\lhead{COMP6223}
\rhead{Olivia Wilson: 22277935}
\chead{oew1v07@soton.ac.uk}

\setlength{\textheight}{700pt}
\setlength{\topmargin}{-12pt}
\setlength{\droptitle}{-6em}

\definecolor{cgreen}{HTML}{b5bd68}
\definecolor{cred}{HTML}{cc6666}
\definecolor{cblue}{HTML}{81a2be}

\lstset{frame=single,
    language=python,
    basicstyle=\ttfamily\small,
    tabsize=4,
    showstringspaces=false,
    keywordstyle=\color{cred},
    identifierstyle=\color{cblue},
    commentstyle=\color{cgreen}}

% work out what word wrap I need.

\title{COMP 6223: Image Filtering and Hybrid Images}
\predate{}
\date{}
\postdate{}
\author{}
\preauthor{}
\postauthor{}


\begin{document}
\maketitle
\thispagestyle{fancy}

\section{Convolved}
Talk about how I implemented the convolve. I check for even and dimensions > 2
in kernels and more than 3 dimensions in images.

I use the inbuilt option in fftn to pad the image and kernel with zeros.

To deal with 3 band images I use recursion to call convolve for each of the three
bands separately and put them back together.

I used fft because it scales well for large kernels (which when sigma is as it is
became a necessary feature). I then multiplied the two ffts, inversed and took
their real part. Finally I remove the padding.

Used TDD to then sanity check my code.

\begin{lstlisting}
def convolve(image, kernel):
    """Convolves a kernel over an image using the fast fourier transform.

    Parameters
    ----------
    image: ndarray (arbitrary shape,float or int type)
        Image to be convolved over. It is expected that images will be of the
        shape (x,y,z) where z is the number of bands (1 or 3)
    kernel: ndarray
        Kernel to convolve with of odd shape not necessarily square.

    Raises
    ------
    TypeError
        If the input kernel is of even shape in one or both dimensions.

    Returns
    -------
    out: ndarray, same shape as input `image`
        The convolved image
    """

    # Check if size is odd then both rows and columns must be odd
    _odd(kernel.size)

    # Check dimensions for kernel are two or fewer
    _dim(kernel.ndim)

    # Check that any dimensions with a "single" column are squeezed for kernels
    # or image
    image = np.squeeze(image)
    kernel = np.squeeze(kernel)

    # Checks dimensionality of image for if we need to do colour convolving
    if image.ndim > 2:
        if image.ndim > 3:
            raise ValueError("Image should have no more than 3 bands "
                             "Got {number}.".format(number = image.ndim))
        else:
            # Create output array for multiple
            output = np.zeros(image.shape)

            for i in range(image.shape[2]): # Gets the number of 3d bands
                image_it = image[:,:,i]
                output[:, :, i] = convolve(image_it,kernel)

            return output

    # Creates variable for later use to return original sized image
    image_size = image.shape

    # Creates variable of how many rows with which the image needs to be padded
    pad_shape = np.array(image.shape) + int(np.floor(len(kernel)/2))*2
    pad_shape = list(pad_shape)

    # Calculate FFT for image: using the option to pad with zeros to the
    # the necessary size
    fft_image = fftpack.fftn(image, shape = pad_shape)

    # Calculate FFT for kernel using the option to pad the kernel with zeros to
    # make it the shape of the padded image.
    fft_kernel = fftpack.fftn(kernel, shape = pad_shape)

    # Multiply the fourier tranforms by element
    fft_convolved = fft_image * fft_kernel

    # Calculate the inverse fourier of the convolved image
    convolved = np.fft.ifftn(fft_convolved)

    # Calculate how much padding has been added by the fft
    expanded = np.array(convolved.shape) - np.array(image_size)

    # Padding by the fft is always equal on each side so taking half of the
    # difference provides padding on each side.
    pad = int((expanded/2)[0])

    # Index the new array to get the central array without the padding
    out = convolved[pad:-pad, pad:-pad]

    # Take the real part of the convolved array
    out = np.real(out)

    return out
\end{lstlisting}

\section{Hybrid Images}
How I did it, why and outputs. Implemented code to create the decreasing size
visualisation. Animations of different sigmas.

\todo{do einstein Marilyn with lower sigma values for einstein.}

\todo{README}

\todo{License}

\todo{command line running}

\todo{Work out best image pairs}

\end{document}
