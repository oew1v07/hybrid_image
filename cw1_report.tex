\RequirePackage[l2tabu, orthodox]{nag}

\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{layout}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{microtype}
\usepackage{bm}
\usepackage{titling}
\usepackage[a4paper]{geometry}
\usepackage{parskip}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{subcaption}


\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{cleveref}

\newcommand{\todo}[1] {\textbf{\textcolor{red}{#1}}}
\makeatletter
\newcommand{\xRightarrow}[2][]{\ext@arrow 0359\Rightarrowfill@{#1}{#2}}
\makeatother

\fancyhead{}
\lhead{COMP6223}
\rhead{Olivia Wilson: 22277935}
\chead{oew1v07@soton.ac.uk}

\setlength{\textheight}{700pt}
\setlength{\topmargin}{-12pt}
\setlength{\droptitle}{-6em}

\definecolor{cgreen}{HTML}{b5bd68}
\definecolor{cred}{HTML}{cc6666}
\definecolor{cblue}{HTML}{81a2be}

\lstset{frame=single,
    language=python,
    basicstyle=\ttfamily\small,
    tabsize=4,
    showstringspaces=false,
    keywordstyle=\color{cred},
    identifierstyle=\color{cblue},
    commentstyle=\color{cgreen}}

\title{COMP 6223: Image Filtering and Hybrid Images}
\predate{}
\date{}
\postdate{}
\author{}
\preauthor{}
\postauthor{}


\begin{document}
\maketitle
\thispagestyle{fancy}

\section{Implementation Style}
I have written this piece of code in Python 3 because it is a widely used
scientific programming which is widely used in my workplace for image processing
tasks. In implementing this algorithm, I used test driven development to test the code
thoroughly whilst developing it, as well as to ensure continued development did
not break previous functionality. Not all functions are tested, only ones that
are key to the running of the script, such as the convolve function, which is
used by many other functions.

I have also ensured that all my inputs are sanitised because it is better to
`fail fast',rather than continue and create less easily detectable errors.
Checks include: kernels must be odd and 2 dimensional, type checking for all
inputs, images must either be 1 or 3 dimensions. I followed standard Python
programming style known as PEP8(\url{https://www.python.org/dev/peps/pep-0008/})
for readability and reproducibility.

Finally, Doc strings which are
integrated into the Python interpreter have also been used as a reminder. This
script can also be run from the command line using the by running the following
command \lstinline|python 'dog.bmp' 'cat.bmp' sigma| with the first and second
arguments as the low pass  and high pass image respectively.

\section{Convolve Implemetation}
For my implementation of the convolve function see section~\ref{lst:convolve}. I
decided to use the Fast Fourier Transform (FFT), for its scalability
for larger kernel sizes. In some of the examples $\sigma$ can increase to values
of 5 or 6 with kernel sizes being 40 or 50 square, requiring the speed of the
FFT

To begin, I calculate the size by which the image should be padded to add a
border of zeros, which is the floor of half the kernel size. Using
\lstinline|fftn| from the scipy library, the inbuilt option to pad with constant
values of 0 is used, for both the image and the kernel. This ensures that
image and kernel are the same shape to then multiply later. After
calculating the FFT I then multiply the image FFT and the kernel FFT
elementwise, calculate the inverse FFT and take their real part. Finally the
padding is removed to provide an output the same size as the original. To deal with 3 band
images I use recursion to call convolve for each of the three bands separately
and then after convolve has run put them back together manually.

\section{Hybrid Images}
To implement the hybrid images algorithm I wrote a number of seperate
functions each of which produces intermediate outputs which could be
saved if necessary. Hence, \lstinline|low_pass| calls \lstinline|convolve| and
\lstinline|create_gaussian_kernel|, \lstinline|high_pass| calls \lstinline|low_pass|
and finally all the separate functions are combined by \lstinline|run_hybrid|.
\lstinline|run_hybrid| also has the option to iterate over a number of different
$\sigma$'s to save time when the output needs checking for the optimal
configuration.

I investigated the cut-off frequency and the effect it has on the images in more
depth. The results from this are qualitative but nonetheless
interesting to study. In particular I started with the cat and dog combination
to test the model due to prior knowledge of the outcome. Initially I ran for $\sigma$'s
from 0.5 to 3.5, but on further inspection, the resulting images did not
reflect the picture shown in the specification or Figure~\ref{fig:dog_cat}.
Increasing the $\sigma$ range to 6.5 helped to find a suitable hybrid image.
This image had a sigma of 6, requiring a kernel of size 43 x 43, which would
have been unfeasible for a loop-based convolve function.

% Put benchmark here?
Further investigations found that none of the other images needed
such a high sigma value as that pair, which is why I have a range of $\sigma$'s
that go from 1 to 4.5. Anything below 1 tends to not have changed either image
enough to be considered as a hybrid, and above 4.5 was only needed for the cat
dog pairing. With Einstein and Marilyn (Figure~\ref{fig:einstein_marilyn}), if
the high pass Marilyn had $\sigma > 2.5$ then there was, `too much
Marilyn' when viewing a small image (when Einstein should be more visible).
Discovering this I found the easiest way to search for a good hybrid was to
preview a small image and reject ones where the high pass image came through too
clearly.

The other impact on clarity of hybrid image is the order in which the hybrid is
created. The low pass image has to be something that will not overpower the
entire image. A good example of this is the combination of bicycle and motorcycle.
With motorcycle as the low pass image, too much of the orange colour overpowers
the image of the bicycle (seen in Figure REF HERE, the best hybrid I could find).
Whereas with the motorcycle as the high pass image, the hybrid comes through
clearly (as shown in Figure REF HERE).

\begin{figure}[ht!]
    \centering
    \includegraphics[width = 0.8\textwidth]{dog_cat_35_60.png}
    \caption{Hybrid Image of a cat (high pass image) and dog (low pass image)
             with $\sigma$ of 6 and 3.5 respectively. \label{fig:dog_cat}}
\end{figure}

\begin{figure}[ht!]
    \centering
    \includegraphics[width = 0.8\textwidth]{einstein_marilyn_30_10.png}
    \caption{Hybrid Image of a Marilyn Monroe (high pass image) and Albert Einstein (low pass image)
             with $\sigma$ of 1 and 3 respectively. \label{fig:einstein_marilyn}}
\end{figure}

% \begin{figure}[ht!]
%     \centering
%     \begin{subfigure}[b]{0.3\textwidth}
%         \includegraphics[width=\textwidth]{cat_high_pass_sigma_60.png}
%         \caption{High pass image of cat.bmp $\sigma = 6$\label{fig:high_cat}}
%     \end{subfigure}
%     ~%add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
%     \begin{subfigure}[b]{0.3\textwidth}
%         \includegraphics[width=\textwidth]{dog_low_pass_sigma_35.png}
%         \caption{Low pass image of dog.bmp $\sigma = 3.5$\label{fig:low_dog}}
%     \end{subfigure}
% \caption{Intermediate steps for the cat dog hybrid image. \label{fig:intermediate}}
% \end{figure}

Implemented code to create the decreasing size
visualisation. Animations of different sigmas.

motorcycle/bike vs bike/motorcycle

\todo{README}

\todo{License}

\todo{command line running}

\todo{Work out best image pairs}

\newpage
\section{Appendix}

\begin{lstlisting}[caption = , label = lst:convolve]
def convolve(image, kernel):
    """Convolves a kernel over an image using the fast fourier transform.

    Parameters
    ----------
    image: ndarray (arbitrary shape,float or int type)
        Image to be convolved over. It is expected that images will be of
        the shape (x,y,z) where z is the number of bands (1 or 3)
    kernel: ndarray
        Kernel to convolve with of odd shape not necessarily square.

    Raises
    ------
    ValueError
        If the input kernel is of even shape in one or both dimensions.

    Returns
    -------
    out: ndarray, same shape as input `image`
        The convolved image
    """

    # Check if size is odd then both rows and columns must be odd
    _odd(kernel.size)

    # Check dimensions for kernel are two or fewer
    _dim(kernel.ndim)

    # Check that any dimensions with a "single" column are squeezed for
    # kernels or image
    image = np.squeeze(image)
    kernel = np.squeeze(kernel)

    # Checks dimensionality of image for if we need to do colour
    # convolving
    if image.ndim > 2:
        if image.ndim > 3:
            raise ValueError("Image should have no more than 3 bands "
                             "Got {number}.".format(number = image.ndim))
        else:
            # Create output array for multiple
            output = np.zeros(image.shape)

            for i in range(image.shape[2]): # Gets the number of 3d bands
                image_it = image[:,:,i]
                output[:, :, i] = convolve(image_it,kernel)

            return output

    # Creates variable for later use to return original sized image
    image_size = image.shape

    # Creates variable of how many rows with which the image needs to be
    # padded
    pad_shape = np.array(image.shape) + int(np.floor(len(kernel)/2))*2
    pad_shape = list(pad_shape)

    # Calculate FFT for image: using the option to pad with zeros to the
    # the necessary size
    fft_image = fftpack.fftn(image, shape = pad_shape)

    # Calculate FFT for kernel using the option to pad the kernel with
    # zeros to make it the shape of the padded image.
    fft_kernel = fftpack.fftn(kernel, shape = pad_shape)

    # Multiply the fourier tranforms by element
    fft_convolved = fft_image * fft_kernel

    # Calculate the inverse fourier of the convolved image
    convolved = np.fft.ifftn(fft_convolved)

    # Calculate how much padding has been added by the fft
    expanded = np.array(convolved.shape) - np.array(image_size)

    # Padding by the fft is always equal on each side so taking half of
    # the difference provides padding on each side.
    pad = int((expanded/2)[0])

    # Index the new array to get the central array without the padding
    out = convolved[pad:-pad, pad:-pad]

    # Take the real part of the convolved array
    out = np.real(out)

    return out
\end{lstlisting}

\end{document}
